#! /usr/bin/env python
import os
import subprocess
import shutil
import urllib2
from distutils.dir_util import mkpath


BUILD_ENVIRON = {
    'PATH': os.pathsep.join(['/usr/bin', '/bin', '/usr/sbin', '/sbin',
                             '/etc', '/usr/lib']),
    'HOME': os.path.expanduser('~'),
}

def miniconda_url(version='3.7.0', python='', url=None):
    url = url or 'http://repo.continuum.io/miniconda'

    if is_linux_os():
        os = 'Linux-x86_64'
    else:
        os = 'MacOSX-x86_64'
    file = 'Miniconda{python}-{version}-{os}.sh'.format(
        python=python, version=version, os=os)

    return '/'.join([url, file])


class create_and_change_dir(object):
    def __init__(self, dir):
        self._dir = dir

    def __enter__(self):
        self._starting_dir = os.path.abspath(os.getcwd())
        if not os.path.isdir(self._dir):
            mkpath(self._dir)
        os.chdir(self._dir)
        return os.path.abspath(os.getcwd())

    def __exit__(self, type, value, traceback):
        os.chdir(self._starting_dir)


def which(prog, env=None):
    prog = os.environ.get(env or prog.upper(), prog)

    try:
        prog = subprocess.check_output(['which', prog],
                                       stderr=open('/dev/null', 'w')).strip()
    except subprocess.CalledProcessError:
        return None
    else:
        return prog


def which_git():
    return which('git')


def which_brew():
    return which('brew')


def which_python():
    return which('python')


def which_cc():
    return which('gcc', env='CC')


def which_cxx():
    return which('g++', env='CXX')


def which_java():
    return which('java')


def gcc_version():
    version_s = subprocess.check_output([which_cc(), '-dumpversion']).strip()
    (major, minor, micro) = version_s.split('.')
    return '%s.%s' % (major, minor)


def brew_prefix():
    brew = which('BREW')
    brew_bindir = os.path.dirname(brew)
    return os.path.dirname(brew_bindir)


def system(*args, **kwds):
    verbose = kwds.pop('verbose', True)

    status(' '.join(args[0]))

    if verbose:
        call = subprocess.check_call
    else:
        call = subprocess.check_output

    try:
        call(*args, **kwds)
    except subprocess.CalledProcessError:
        status('Error')
        raise


def ln_s(src, dst):
    if not os.path.exists(dst):
        system(['ln', '-s', src, dst])


def git_clone(url, git=None, dir='.'):
    git = git or which('git')

    with create_and_change_dir(dir) as dir:
        system([git, 'init', '-q'])
        system([git, 'config', 'remote.origin.url', url])
        system([git, 'config', 'remote.origin.fetch',
                '+refs/head/*:refs/remotes/origin/*'])
        system([git, 'fetch', 'origin',
                'master:refs/remotes/origin/master', '-n', '--depth=1'])
        system([git, 'reset', '--hard', 'origin/master'])


def git_pull(url, dir='.'):
    with create_and_change_dir(dir) as dir:
        system(['git', 'checkout', '-q', 'master'])
        system(['git', 'pull', 'origin', '-q',
                'refs/heads/master:refs/remotes/origin/master'])


def git_clone_or_update(url, dir='.'):
    if os.path.isdir(os.path.join(dir, '.git')):
        status('Updating %s' % url)
        git_pull(url, dir=dir)
    else:
        status('Cloning %s' % url)
        git_clone(url, dir=dir)


def brew(formula, brew=None, taps=[], args=[]):
    brew = brew or which('brew')

    for tap in taps:
        system([brew, 'tap', tap])
    system([brew, 'install', formula] + args)


def is_linux_os():
    import sysconfig
    return sysconfig.get_platform().startswith('linux')


def status(message):
    print ' '.join(['==>', message])


def prepend_path(var, path):
    if var in os.environ:
        os.environ[var] = os.pathsep.join([path, os.environ[var]])
    else:
        os.environ[var] = path


def create_and_prepend_path(var, path):
    mkpath(path)
    prepend_path(var, path)


def python_version(python):
    return subprocess.check_output(
        [python, '-c', 'import sys; print(sys.version[:3])']).strip()


def python_site_packages(python):
    return os.path.join('lib', 'python%s' % python_version(python),
                        'site-packages')


def fetch_homebrew(dir='.', url=None):
    if url is None:
        if is_linux_os():
            url = 'https://github.com/Homebrew/linuxbrew'
        else:
            url = 'https://github.com/Homebrew/homebrew'

    git_clone_or_update(url, dir=dir)


def fetch_wmt_exe(dir='.', url=None):
    git_clone_or_update(url or 'https://github.com/csdms/wmt-exe', dir=dir)


def install_homebrew(prefix, dir='.'):
    with create_and_change_dir(prefix) as base:
        fetch_homebrew(dir=dir)

        if is_linux_os():
            with create_and_change_dir(os.path.join(dir, 'bin')):
                ln_s(which_cc(), 'gcc-%s' % gcc_version())
                ln_s(which_cxx(), 'g++-%s' % gcc_version())
                ln_s(which_python(), 'python')

    brew = os.path.join(prefix, dir, 'bin', 'brew')

    return os.path.abspath(brew)



def install_wmt_exe(prefix, dir='.'):
    optdir = os.path.join(prefix, 'opt', 'wmt-exe')
    with create_and_change_dir(optdir):
        fetch_wmt_exe()

        create_and_prepend_path(
            'PYTHONPATH', os.path.join(
                prefix, python_site_packages(which_python())))

        configure_args = [
            '--wmt-prefix=%s' % prefix,
            '--components-prefix=%s' % prefix,
            '--clobber',
            ]

        system(['python', 'setup.py', 'configure'] + configure_args)
        system(['python', 'setup.py', 'develop', '--prefix=%s' % prefix])

        etcdir = os.path.join(prefix, 'etc')
        mkpath(etcdir)

        shutil.copy('wmt.cfg', etcdir)


def install_csdms_stack(prefix):

    #prepend_path('PATH', os.path.join(prefix, 'bin'))
    #prepend_path('LD_LIBRARY_PATH', os.path.join(prefix, 'lib'))

    args = ['--HEAD', '-v']
    if is_linux_os():
        args += ['--with-java=/usr/local/java/bin/java',
                 '--with-python=/usr/local/epd/bin/python']

    brew('cmi', taps=['csdms/tools', 'csdms/models', 'csdms/dupes'], args=args)


def checksum_matches(path, md5):
    import hashlib

    hasher = hashlib.md5()
    with open(path, 'r') as contents:
        hasher.update(contents.read())

    return hasher.hexdigest() == md5


def download_miniconda(dest, cache='.'):
    md5 = '2656c37fd8a1a384650d7f09407a0893'

    dest = os.path.abspath(os.path.join(cache, dest))

    if os.path.exists(dest):
        if checksum_matches(dest, '2656c37fd8a1a384650d7f09407a0893'):
            status('md5 %s' % miniconda_url())
            return dest
        else:
            os.remove(dest)

    status('Fetching %s' % miniconda_url())

    try:
        response = urllib2.urlopen(miniconda_url())
    except urllib2.HTTPError as error:
        raise
    except urllib2.URLError as error:
        raise
    else:
        with open(dest, 'w') as destination:
            shutil.copyfileobj(response, destination)

    return os.path.abspath(dest)


def set_build_environ(keep=[], env=None):
    for key in os.environ.keys():
        if key not in keep:
            del os.environ[key]
    os.environ.update(env)


def install_python(prefix, dir='.'):
    import urllib2

    cache = os.path.join(prefix, 'var', 'cache')
    with create_and_change_dir(cache):
        miniconda = download_miniconda('miniconda.sh')

    conda_prefix = os.path.join(prefix, 'opt', 'conda')
    with create_and_change_dir(conda_prefix) as base:
        conda = os.path.join(base, 'bin', 'conda')

        env_bindir = os.path.join(base, 'envs', 'wmt', 'bin')

        if not os.path.exists(conda):
            system(['bash', miniconda, '-f', '-b', '-p', base])

            system([conda, 'config',
                    '--set', 'always_yes', 'yes',
                    '--set', 'changeps1', 'no'])
            system([conda, 'update', 'conda'])

        if not os.path.isdir(env_bindir):
            requirements = ['python=2.7', 'numpy', 'scipy', 'setuptools']
            system([conda, 'create', '-n', 'wmt'] + requirements)

        system([conda, 'update', '-n', 'wmt', '--all'])

        ln_s(os.path.join(env_bindir, 'python'),
             os.path.join(prefix, 'bin', 'python'))

    return os.path.join(env_bindir, 'python')


if __name__ == '__main__':
    import argparse

    git = which('git')
    cc = which('gcc', env='CC')
    cxx = which('g++', env='CXX')
    java = which('java')

    parser = argparse.ArgumentParser()
    parser.add_argument('prefix', help='Install prefix for wmt-exe')
    parser.add_argument('--verbose', action='store_true',
                        help='Be verbose')

    parser.add_argument('--with-python', default='internal',
                         metavar='PYTHON',
                         help='Path to Python executable [internal]')
    parser.add_argument('--with-brew', default='internal',
                         metavar='BREW',
                         help='Path to brew executable [internal]')

    parser.add_argument('--with-git', default=git, metavar='git',
                        required=not git,
                        help='Path to git executable [%s]' % git)
    parser.add_argument('--with-cc', default=cc,
                        metavar='cc', required=not cc,
                        help='Path to C compiler [%s]' % cc)
    parser.add_argument('--with-cxx', default=cxx,
                        metavar='cxx', required=not cxx,
                        help='Path to C++ compiler [%s]' % cxx)
    parser.add_argument('--with-java', default=java,
                        metavar='java', required=not java,
                        help='Path to Java executable [%s]' % java)

    args = parser.parse_args()

    BUILD_ENVIRON.update(dict(git=git, cc=cc, cxx=cxx, java=java))
    set_build_environ(env=BUILD_ENVIRON)

    install_prefix = os.path.abspath(args.prefix)
    with create_and_change_dir(install_prefix) as base:
        for dir in ['bin', 'etc', 'tmp', 'var/log', 'var/cache', 'opt']:
            if not os.path.isdir(dir):
                mkpath(dir)

    if args.with_python == 'internal':
        #os.environ['PYTHON'] = install_python(install_prefix, dir='miniconda')
        os.environ['PYTHON'] = install_python(install_prefix)
    else:
        os.environ.setdefault('PYTHON', args.with_python)

    if args.with_brew == 'internal':
        os.environ['BREW'] = install_homebrew(install_prefix, dir='homebrew')
    else:
        os.environ.setdefault('BREW', args.with_brew)

    with create_and_change_dir(install_prefix) as dir:
        install_csdms_stack(dir)
        install_wmt_exe(dir)

        #fetch_wmt_exe(dir='wmt-exe')

    status('Finished')
